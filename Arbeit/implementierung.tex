
\chapter{Implementierung}
\label{chapter-implementierung}
Das folgende Kapitel beschreibt die Implementierung des Backends,
Reservierungsinterfaces sowie des Fontends. Zunächst wird die Implementierung
des Reservierungsinterfaces und die damit einhergehende technischen Aspekten
beschreiben. Bei wird aufschluss über die Struktur gegben und die
Kernfunktionalität sowie Sackgassen in der Realisierung werden näher erläutert.
Daraufhin wird die Umsetzung des Frontend beschreiben. Abschließend wird auf die
Inbetriebnahme des Systems eingegangen.


\section{Implementierung des Reservierungsinterfaces}
Der Abschnitt beschreibt die Struktur des Reservierungsinterface mit seinen
technischen Aspekten und die Implementierung der Funktionalitäten
(\ref{section:funktionale}). Zunächst wird die Implementierung der
Kernfunktionalitäten erläutert. Daraufhin werden Sackgassen thematisiert.


\subsection{Struktur des Reservierungsinterface}
Das folgende Unterkapitel geht auf die Strukturen und Teilkomponenten des
Reservierungsinterface ein. In \ref{fig:db} wird die Verzeichnisstruktur
präsentiert. Das Reservierungsinterface teilt sich in drei wesentliche
Bausteine: \textit{node, SQLit(prisma)} und \textit{server.ts} .

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.7]{Bilder/Db.jpg}
  \caption[Verzeichnisstruktur des Reservierungsinterfaces]{Verzeichnisstruktur des Reservierungsinterfaces}
  \label{fig:db}
\end{figure}

Der \textit{node} Ordner gibt... .



\textit{server.ts} für Routen


Die für das Reservierungsinterface entwickelte API lässt sich in drei Bereiche teilen:
\textit{Assets}, \textit{Kategorien} und \textit{Reservierungen} (\ref{table:impl-backend-routes}).
In der angelegten API werden die verschiedenen Routen des Inhaltstypen festgelegt. Für jede Route
wird die HTTP-Methode, der entsprechende Pfad (z. B. \textit{/assets/:id}) zugewiesen. Die von
\citeA{fielding_hypertext_2014} beschriebenen Semantik für HTTP-Methode sollte bei der Wahl je nach
Funktion der Route zu Betracht gezogen werden. Folglich sollte die \textit{GET}-Methode verwendet
werden, um ausschließlich Daten zurückzuerhalten. Während eine Anfrage mit übermittelnden Daten die
\textit{POST}-Methode verwendet, welche Daten einen neuen Eintrag im System erschaffen.

Um ein Asset zu reservieren, wird eine \textit{POST}-Anfrage an \textit{/reservation/id} abgeschickt. Für die
Anfrage in Snipe-IT wird wiederum eine \textit{/reservation/receive} \textit{POST}-Anfrage gesendet.
\ref{fig:orm} stellt die mit \textit{prisma} entwickelte Datenbank als Object Relational Mapper
(ORM) mit folgendem Schema dar. \textit{User} können \textit{Reservierungen} aufgeben.


\begin{table}[h]
  \centering
  \caption{API des Reservierungsinterfaces}
  \begin{tabular}{lll}
    \arrayrulecolor{maincolor}\hline
    \sffamily\color{maincolor}Methode & \sffamily\color{maincolor}Route           & \sffamily\color{maincolor}Funktion             \\
    \arrayrulecolor{maincolor}\hline
      GET               & \textit{/assets}       & Erhalte alle Assets \\
      GET               & \textit{/assets/:id}   &
      Erhalte ein Asset mit der entsprechend ID                               \\
      GET               & \textit{/categories} &
      Erhalte alle Kategorien                                        \\
      GET               & \textit{/reservation} &
      Erhalte Reservierungen                                       \\
      POST              & \textit{/reservation}       &
      Erstellen Reservierung                                            \\
      POST              & \textit{/reservation/receive}       &
      Erstellen Reservierung                                           \\
      POST              & \textit{/reservation/return}       &
      Erstellen Reservierung                                                \\
      POST              & \textit{/reservation/id}       &
      Erstellen Erstellen Reservierung                                                \\
      DELETE            & \textit{/reservation/delete}   &
      Löschen Reservierungen                         \\
      PATCH               & \textit{/reservation/patch}   & Verändern Reservieurng       \\
    \arrayrulecolor{maincolor}\hline
  \end{tabular}
  \label{table:impl-backend-routes}
\end{table}

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.2]{Bilder/drawSQL-export-2022-10-09_15 56.png}
  \caption[Datenstruktur der Reservierungen in Verbindung mit Nutzenden]{Datenstruktur der Reservierungen in Verbindung mit Nutzenden}
  \label{fig:orm}
\end{figure}


\subsection{Implementierung der Kernfunktionalität}
Dieser Abschnitt präsentiert die Implementierung der Kernfunktionalität des Zwischenbackends, welche
aus den Anforderungen bestimmt wurden (\ref{section:anforderung}). Bei der Funktionalität handelt es
sich um das Reservieren in die Zukunft, sowie das Speichern dieser Vorgänge und die damit
einhergehende Bestätigung für die Aktualisierung in Snipe-IT. Konkret wird auf das LDAP-System und
das Reservieren von Assts eingegangen. 

Um auf die Assets zugreifen zu können wurde mit der Snipe-IT JSON REST API gearbeitet. Die Snipe-IT
API umfasst viele Ressourcen. Relevante Ressourcen für die Umsetzung der Arbeit waren \textit{/hardware,
/statuslabels, /users, /categories}. Mithilfe dieser konnten die Assets der Beispieldatenbank
verwendet werden. \ref{fig:snipe} zeigt die Beziehungen der API, beispielsweise ist ein
\textit{/statuslabel} immer an einen \textit{/user} gebunden. 

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.2]{Bilder/drawSQL-export-2022-10-12_17 27.png}
  \caption[UML Snipe-IT API]{UML Snipe-IT API}
  \label{fig:snipe}
\end{figure}

Um mit der API arbeiten zu können muss ein \textit{API
  key}\footnote{\url{https://snipe-it.readme.io/reference/generating-API-tokens}}
  generiert werden. Da persönliche Zugriffstoken verwendet werden, spiegeln die
  Berechtigungen des API-Tokens die Berechtigungen des Nutzenden wider. Das
  bedeutet, dass die Token lediglich manuell im Dashboard generierbar sind.
  Was zur Folge hat, dass das geplante LDAP-System der Universität zu Lübeck
  nicht ohne Umstände eingebunden und entsprechend genutzt werden kann. Snipe-IT
  gibt unter anderem die Möglichkeit, das LDAP
  Formular\footnote{\url{https://snipe-it.readme.io/docs/ldap-sync-login}}
  simpel einzubinden, trotz dessen besteht das Problem, der Authentifizierung
  sowie Generierung der Tokens, da die Daten im Reservierungsinterface bis
  dato nicht übertragen werden können. Dies führt zu einem Datenschutzproblem.

Die für das Frontend benötigten Ressourcen wurden über den angelegten Routen erstellt. Zur
Unterstützung wurde \textit{Fastify} verwendet. \textit{Fastify} ist ein Webframework für
\textit{Node.js}. Das Framework verfügt über vielerlei Plugins und ist daher gut erweiterbar,
außerdem erleichter es DINGE.

Der eigentliche Kern der Anwendung befasst sich mit dem Reservieren der Assets. Hierfür müssen die
Daten (Assetname, Datum, Uhrzeit, Ort, \dots) gespeichert werden. Bevor ein Status eines Assets in
Snipe-IT von \textit{verfügbar} zu \textit{herausgegeben} geändert wird, werden die Daten für eine
Reservierung im Reservierungsinterfaces zwischengespeichert. Für diesen Schritt wurde SQLite
verwendet. Zusätzlich wurde für eine leichtere Verwaltung der angelegten Datenbank Prisma genutzt.
Die von Snipe-IT zur Verfügung gestellten Möglichkeiten des der Statuseingabe/Ausleihen schwer und
komisch -> rumarbeiten.

\todo[inline]{Gibt es sonst etwas Wichtiges, was man hier erwähnen sollte? Code beispeile?}

\section{Implementierung des Frontends}
Das kommende Unterkapitel beschreibt die Client-seitige Realisierung der Arbeit. Zunächst wird der
Aufbau betrachtet (\ref{fig:vue}), daraufhin wird die Nutzung von vue und XXX erläutert. Des
Weiteren wird auf die Struktur der Komponenten eingegangen (\ref{fig:komponenten}). Abschließend
wird das native App-Erlebnis thematisiert.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.7]{Bilder/Db.jpg}
  \caption[Verzeichnisstruktur des Reservierungsinterfaces]{Verzeichnisstruktur des Reservierungsinterfaces}
  \label{fig:vue}
\end{figure}

Für den Aufbau des Projektes wurde aus den in \ref{chapter-konzept} festgestellten Anforderungen
\textit{vue.js} verwendet. Bei der Implementierung wurde sich an den best practices der
Vue.js-Dokumentation orientiert \todo{(Vue.js, 2021a)}. Für sich wiederholende Elemente wurden
eigene Views erstellt. Dadurch ergibt sich eine hierarchisch geschachtelte Client-Anwendung der
Vue-Komponenten. \ref{fig:Komponenten} stellt die Komponenten-Struktur vereinfacht dar. Um
konkretere Vorschläge in der Entwicklungsumgebung zu ermöglichen und vorzeitige Fehler zu minimieren
wurde ergänzt zu \textit{JavaScript} \textit{TypeScript} verwendet.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.5]{Bilder/struktur.pdf}
  \caption[Vereinfachte Struktur der Komponenten]{Vereinfachte Struktur der Komponenten}
  \label{fig:Komponenten}
\end{figure}

Um das Styling zu vereinfachen wurde \textit{Tailwindcss} genutzt. Ergänzend dazu wurde
\textit{Preline} für UI verwendet. -> Nicht empfehlenswert (Sackgassen).
Für Animationen und Transitionen wurde \textit{HeadlessUi} genutzt.

Der Kalender stellt einen wichtigen Bestandteil für das Reservieren von Assets dar. Die
Kalenderkomponente wurde durch \textit{v-calender} ergänzt. Durch die Möglichkeiten der Komponente
...??. Außerdem bietet diese viele Ausbaumöglichkeiten für folgende Funktionalitäten.

Die im Rahmen dieser Arbeit verwendete Beispieldatenbank beinhaltete eine Vielzahl an Kategorien und
Unterkategorien, welche wie folgt, eingetragen wurde: \enquote{Kategorie - Unterkategorie}. Da das
Anzeigen von den Kategorien unübersichtlich ist, sollten zunächst nur die Kategorien und dann die
Unterkategorien angezeigt werden. \ref{fig:categoriecode} stellt den Entwickelten Algorithmus als
Pseudocode dar. Der \enquote*{-} wurde dazu als Trennsymbol verwendet. Daraufhin wurden der
Vorderteil als Kategorie verwendet und der Hintere Als Unterkategorie. Um die Kategorien und
Unterkategorien nicht doppelt anzeigen zulassen, wurde eine abfragen gemacht, bei welcher diese dann
abgeglichen wurden bis keine Gleichheit mehr bestand und die nächste Kategorie angezeigt werden
kann, bis alle Kategorien und Unterkategorien verglichen wurden.

\begin{lstlisting}[style=pseudo,gobble=2,caption={Pseudocode: Kategorien anzeigen},label=fig:categoriecode]
  // Trennung am Strich
    for $- \gets Kategorie$ to $Unterkapitel$ do
      ICH BIN DUMM
\end{lstlisting}


\section{Nutzung des Systems}
Der folgende Abschnitt führt die nötigen Schritte auf, um das System in Betrieb
nehmen zu können. Zuerst wird die Installation erklärt, gefolgt von der Konfiguration und Ausführung
des Systems. 

\subsection{Installation}
Für die Nutzung des Systemes wird eine Installation von \textit{Node.js} sowie der Paket-Manager
\textit{npm} benötigt. Anschließend, kann das System auf \dots

\subsection{Konfiguration}
.env Datei angelegen

Code einfügen

\subsection{Ausführung von Snipe-IT}
Um das System Nutzen und weiterentwicklen zu können muss... API KEy generieren
lassen.

\subsection{Ausführung der Web-App}
\todo[inline]{Zum Ausführen oder Bereitstellen der Web-App muss diese vorher noch „gebaut“ werden.
Hierbei handelt es sich um einen Prozess, in dem der Quellcode auf ein Minimum
reduziert wird. Externe Pakete werden eingebunden und ungenutzter Code, soweit möglich,
entfernt. Um diesen Prozess anzustoßen, muss im Stammverzeichnis der Web-App
der Befehl yarn␣build ausgeführt werden. Nachdem der Bau-Prozess erfolgreich abgeschlossen
ist, sollte ein neues ist Verzeichnis generiert wurden sein. Dieses Verzeichnis
kann nun zum statischen Hosting verwendet werden.}


\section{Fazit der Implementierung}

Sackgassen YEAH
